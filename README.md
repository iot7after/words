# 용어 정리집

## 소프트웨어 생명주기 모델

시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차

## 폭포수 모델

소프트웨어 개발 시 각 단계를 확실히 마무리 지은 후에 다음 단계로 넘어가는 모델

## 프로토타이핑 모델

고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델

## 나선형 모델

시스템 개발 시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 모델

## 반복적 모델

구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 SDLC 모델

## 소프트웨어 개발방법론

소프트웨어를 하나의 생명체로 간주하고 소프트웨어 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정을 형상화한 방법론

## 구조적 방법론

전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 접근 방식의 방법론, 대표적으로 나씨-슈나이더만 차트 사용

### 나씨-슈나이더만 차트

논리의 기술에 중점을 둔 도형식 표현 방법론

## 정보공학 방법론

정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론

## 객체지향 방법론

‘객체’라는 기본 단위로 시스템을 분석 및 설계하는 방법론

## 컴포넌트 기반 방법론

소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론

## 애자일 방법론

절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적용하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론

## 제품 계열 방법론

특정 제품에 적용하고 싶은 공통된 기능을 정의하며 개발하는 방법론

## XP(eXtreme Programming)

의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법혼

## XP의 5가지 가치

용기(Courage), 단순성(Simply), 의사소통(Communication), 피드백(Feedback), 존중(Respect)

## XP의 12가지 원리

짝 프로그래밍, 공통 코드 소유, 지속적인 통합, 계획 세우기, 작은 릴리즈, 에타포어, 간단한 디자인, 테스트 기반 개발, 리팩토링, 40시간 작업고객 상주, 코드 표준

## 스크럼

매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론

### 백로그(Backlog)

제품과 프로젝트에 대한 요구사항

### 스프린트(Sprint)

2~4주의 짧은 개발  기간으로 반복적 수행으로 개발 품질 향상

### 스크럼 미팅(Scrum Meeting)

매일 15분 정도 미팅으로 To-Do List 계획 수립

### 스크럼 마스터(Scrum Master)

프로젝트 리더, 스크럼 수행 시 문제를 인지 및 해결하는 사람

### 스프린트 회고(Sprint Retrospective)

스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부, 개선점 등을 확인 및 기록

### 번 다운 차트(Burn Down Chart)

남아 있는 백로그 대비 시간을 그래픽적으로 표현한 차트

## 린(LEAN)

도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질 향시킨 방법론

### 7가지 원칙

낭비 제거, 품질 내제화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

## 하향식 산정 방법

경험이 많은 전문가에게 비용 산정을 의뢰하거나 여러 전문가와 조정자를 통해 산정을 하는 방식

### 종류

전문가 판단, 델파이 기법

## 상향식 산정 밥법

세부적인 요구사항과 기능에 따라 필요한 비용을 계산하는 방식

### 종류

코드 라인 수(LOC), Man Month, COCOMO 모형, 푸트남 모형, 기능점수(FP) 모형

## COCOMO 모형

보햄(Bohem)이 제안한 모형으로 프로그램 규모에 따라 비용을 산정하는 방식

## 푸트남(Putnam) 모형

소프트웨어 개발 주기의 단계별ㄹ로 요구한 인력의 분포를 가정하는 방식, 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 분포도를 기초로 한다.

## 기능점수(FP:Fuction Point) 모형

요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식

기능 점수(FP) = 총 기능점수 X [0.65 + (0.1 X 총 영향도)]

## 일정관리 모델

프로젝트가 일정 기한 내에 적절하게 완료될 수 있도록 관리하는 모델

## 주 공정법(CPM:Critical Path Method)

여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법

## PERT(Program Evaluation and Review Techique)

일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법

## 중요 연쇄 프로젝트 관리(CCPM: Critical Chain Project Management)

주 공정 연쇄법으로 자원 제약사항을 고려하여 일정을 계산하는 기법

## 현행 시스템 파악

현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 녀계 정보는  무엇이며 어떤 기술 요소를 사용하는지를 파악하는 활동

## 소프트웨어 아키텍처

여러 가지 소프트웨어의 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계르 표현하는 시스템의 구조나 구조체

## 소프트웨어 아키텍처 프레임워크

소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이틀 간의 관계를 제공하는 아키텍쳐 기술 표준

### 아키텍처 명세서

아키텍처를 기록하기 위한 산출물들

### 이해관계자

시스템 개발에 관련된 모든 사람과 조직

### 관심사

시스템에 대해 이해관계자들의 서로 다른 의견과 목표

### 관점

개별  뷰를 개발할 때 토대가 되는 패턴이나 양식

### 뷰

서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현

### 근거

아키텍처 결정 근거

### 목표

환경 안에서 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용, 운용방법

### 환경

시스템에 영향을 주는 요인으로 개발, 운영 등의 외부 요인 등으로 시스템에 영향을 주는 요인

### 시스템

각 애플리케이션, 서브 시스템, 시스템의 집합, 제품군 등이 구현체

## 소프트웨어 아키텍처 4 + 1 뷰

고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법

### 유스케이스 뷰

유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰

### 논리 뷰

시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해 주는 뷰

### 프로세스 뷰

시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰

### 구현 뷰

개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여 주는 뷰

### 배포 뷰

컴포넌트가 물리적인 아키텍처에 어떻게 배치 되는가를 매핑해서 보여주는 뷰

## 소프트웨어 아키텍처 패턴

소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식

## 계층화 패턴

시스템을 계층으로 구분하여 구성하는 패턴

## 클라이언트-서버 패턴

하나의 서버와 다수의 클라이언트로 구성된 패턴

## 파이프 - 필터 패턴

데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴

## 브로커 패턴

분리된 컴포넌트들로 이루어진 분산 시 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실해을 통해 상호작용이 가능한 패턴

## 모델- 뷰-컨트롤러 패턴

대화형 애플리케이션 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴

## SAAM(Software Architecture Analysis Method)

변경 용이성과 가능성에 집중, 평가가 용이하여 결함이 없는 조직에서도 활용 가능한 비용 평가 모델

## ATTM(Architecture Trade-off)

아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상층관계까지 평가하는 모델

## CBAM(Cost Benefit Analysis Method)

ATTM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델

## ADR(Active Design Review)

소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델

## ADR(Active Design Review)

소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델

## ARID(Active Reviews for Intermediate Designs)

전체 아키텍처가 아닌 특정 부분에 대한 품질 요소에 집중하는 비용 평가모델

## 디자인 패턴

소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴

## 생성 패턴

객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴

### 빌더(Builder)

복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(포현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 포현 결과를 만들 수 있는 디자인 패턴

### 프로토타입(Prototype)

처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴

### 팩토리 메서드(Factory Method)

상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식

### 추상 팩토리(Abstract Factory)

구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴

### 싱글톤(Sigleton)

전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴

## 구조 패턴

더 큰 구조 형상 목적으로 클래스나 객체의 조합을 다루는 패턴

### 브리지(Bridge)

기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴

### 데코레이터(Decorator)

기존에 구현되 어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴

### 퍼사드(Facade)

복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮충어 시스템 구조에 대한 파악을 쉽게 하는 패턴

### 플라이웨이트(Flyweight)

다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유함으로써 메모리를 절약하고, ‘클래스의 경량화’를 목적으로 하는 디자인 패턴

### 프록시(Proxy)

실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴

### 컴포지트(Composite)

객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴

### 어댑터(Adapter)

기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴

## 행위 패턴

클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴

### 미디에이터(Mediator)

객체지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체지향에서 가장 중요한 느슨한 결합을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해 주는 디자인 패턴

### 인터프리터(Interpreter)

언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴

### 이터레이터(Iterator)

컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴

### 탬플릿 메서드(Template Method)

어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴

### 옵저버(Observer)

한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다의 의존성을 가지며 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴

### 스테이트(State)

객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는 디자인 패턴

### 비지터(Visitor)

각 클래스 데이터 구조로 부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴

### 커맨드(Command)

실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴

### 스트레티지(Strategy)

알고리즘 군을 정의하고 (추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴

### 메멘토(Memento)

클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴

### 책임연쇄(Chain of responsibility)

정적으로 어떤 기능에 대한 처리의 연결이 하드 코딩되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴

## 운영체제(Operating System)

컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램

## 네트워크(Network)

컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술

## OSI 7 계층 (물데네전세표응)

### 응용 계층(Application Layer)

사용자와 네트워크 간 응용서비스 연결, 데이터 생성

- 전송 단위 : Data, 프로토콜 : HTTP,FTP)

### 표현 계층(Presentation Layer)

데이터 형식 설정과 부호교환, 암/복호화

- 전송 단위 : Data, 프로토콜 : HTTP,FTP)

### 세션 계층(Session Layer)

연결 접속 및 동기제어

- 전송 단위 : Data, 프로토콜 : SSH, TLS)

### 전송 계층(Transport Layer)

신뢰성 있는 통신 보장

- 전송 단위 : Segment, 프로토콜 : TCP, UDP)

### 네트워크 계층(Network Layer)

단말 간 데이터 전송을 위한 최적화된 경로 제공

- 전송 단위 : Packet, 프로토콜 : IP, ICMP)

### 데이터링크 계층(Data Link Layer)

인접 시스템 간 데이터 전송, 전송 오류 제어

- 전송 단위 : Frame, 프로토콜: 이더넷)

### 물리 계층(Physical Layer)

0과 1의 비트 정보를 회선에 보내기 위한 전기력 신호 변화

- 전송 단위 : Bit, 프로토콜 : RS-232C)

## 백본망

각기 다른 LAN이나 부분망 간에 정보를 교환하기 위한 경로를 제공하는 망

## 라우터

3계층 데이터 패킷을 발신지에게 목적지까지 전달하기 위해 최적의 경로를 지정하고, 이 경로를 따라 데이터 패킷을 다음 장치로 전달하는 네트워크 장비

## 스위치

2계층 장비로서, 동일 네트워크 내에서 출발지에 들어온 데이터 프레임을 목적지 MAC 주소 기반으로 빠르게 전달하는 네트워크 장비

## 게이트웨이

컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 네트워크 장비

## 방화벽

외부로부터 불법 칩입과 내부의 불법 정보 유출을 방지하고, 내/외부 네트워크의 상호 간 영향을 차단하기 위한 보안 시스템

## 미들웨어

분산 컴퓨팅 환경에서 응용 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해 주는 소프트웨어

## 요구공학

사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동

## 인터뷰

요구사항 도출 단계로, 이해관계자와 직접 대화를 통해 정보를 구하는 공식적, 비공식적 정보 수집 방법

## 브레인스토밍

요구사항 도출 단계로, 말을 꺼내기 쉬운 분위기로 만들어, 회의 참석자들이 내놓은 아이디들을 비판 없이 수용할 수 있도록 회의

## 델파이 기법

전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 방법

## 롤 플레잉

현실에 일어나는 장면을 설정하고 여러 사람이 각자가 맡은 연기함으로써 요구사항을 분석하고 수집하는 방법

## 워크숍

단기간의 집중적인 노력을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법

## 설문 조사

설문지 또는 여론 조사 등을 통해 간접적으로 정보를 수집하는 방법

## 요구사항 분석 단계 (분개할 협정)

요구사항 분류 → 개념 모델링 생성 및 분석 → 요구사항 할당 → 정형 분석

## 요구사항 명세 원리 및 검증 항목(명완성 일수 추개)

명확성, 완전성, 검증 가능성, 일관성, 수정 용이성, 추적 가능성, 개발 후 이용성

## 요구사항 관리 단계(협기변확)

요구사항 협상 → 요구사항 기준선 설정 → 요구사항 변경관리 → 요구사항 확인 및 검증

## 상호 운용성

다른 목적을 지닌 2개 이상의 시스템들이 상호 간 정보 및 서비스를 교환하면서 효과적으로 운용될 수 있는 시스템의 능력

## 사용자 인터페이스(UI : User Interface)

사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체

## CLI(Command Line Interface)

정적인 텍스트 기반 인터페이스로, 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스

## GUI(Graphical User Interface)

그래픽 반응 기반 인터페이스로, 글픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 사용자 인터페이스

## NUI(Natural User Interface)

직관적 사용자 반응 기반 인터페이스로, 키보드나 마우스 없이 신체 부위를 이용하는 사용자 인터페이스

## OUI(Organic User Interface)

유기적 상호작용 기반 인터페이스로, 현실에 존재하는 모든 사물이 입출력장치로 변화할 수 있는 사용자 인터페이스

## 직관성(Intuitiveness)

UI 설계 원칙 중 하나로, 누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 함

## 유효성(Efficiency)

UI 설계 원칙 중 하나로, 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작

## 학습성(Learnability)

UI 설계 원칙 중 하나로, 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있도록 제작

## 유연성(Flexibility)

UI 설계 원칙 중 하나로, 사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작

## 사용자 중심(UI 설계 지침)

사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공하며, 실사용자에 대해 이해가 바탕이 되어야 함

## 일관성(UI 설계 지침)

버튼이나 조작 방법을 사용자가 기억하기 쉽고 빠르게 습득할 수 있도록 설계해야 함

## 단순성(UI 설계 지침)

조작 방법은 가장 간단하게 작동되도록 하여 인지적 부담 최소화

## 결과 예측 가능(UI 설계 지침)

작동시킬 기능만 보고도 결과 예측이 가능해야 함

## 가시성(UI 설계 지침)

주요 기능을 메인 화면에 노출하여 쉬운 조작이 가능해야 함

## 표준화(UI 설계 지침)

디자인을 표준화하여 기능 구조의 선행 학습 이후 쉽게 사용 가능해야 함

## 접근성(UI 설계 지침)

사용자의 직무, 연령, 성별 등이 고려된 다양한 계층을 수용해야 함

## 명확성

사용자가 개념적으로 쉽게 인지해야 함

## 오류 발생 해결

사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 함

## 가능성(Functionality) (UI 품질 요구사항)

실제 수행 결과와 품질 요구사항과의 차이를 분석하고, 실제 사용 시 정확하지 않은 결과가 발생할 확률과 관련하여 시스템으로 동작을 관찰하기 위한 품질 기준

### 적절성(Suitality)

소프트웨어 제품이 주어진 작업과 사용자의 목표에 필요 적절한 기능들을 제공해 줄 수 있는 소프트웨어적인 능력

### 정밀성(Accuracy)

소프트웨어 제품이 요구되는 정확도로 올바른 결과를 산출할 수 있는 능력

### 상호 운용성(Interoperability)

소프트웨어 제품이 특정 시스템과 상호작용하여 운영될 수 있는 능력

### 보안성(Security)

비인가된 접근을 차단하고, 우연 또는 고의적인 접근을 인지하여 대처할 수 있는 능력

### 호환성(Compliance)

소프트웨어 제품이 비슷한 환경에서 연관된 표준, 관례 및 규정을 준수하는 능력

## 신뢰성(Reliablity) (UI 품질 요구사항)

시스템이 일정한 시간 또는 작동되는 시간 동안 의도하는 기능을 수행함을 보증하는 품질 기준

### 성숙성(Maturity)

소프트웨어 결함으로 인한 고장을 회피할 수 있는 소프트웨어의 능력

### 고장 허용성(Fault tolerance)

소프트웨어 결함이나 인터페이스 오류 시에도 특정 수준 이상의 성능을 유지할 수 있는 능력

### 회복성(Recoverability)

소프트웨어 고장 발생 시 영향을 받은 데이터를 복구하고 성능의 수준을 다시 확보할 수 있는 능력

## 사용성(Usablitiy) (UI 품질 요구사항)

사용자와 컴퓨터 사이에 발생하는 어떠한 행위를 정확하고 쉽게 인지할 수 있는 품질 기준

### 이해성(Understandability)

소프트웨어의 논리적인 개념과 적용 가능성(응용 가능성)을 구분하는 데 필요한 사용자의 노력 정도에 따른 소프트웨어 특성

### 학습성(Learnability)

소프트웨어 애플리케이션 학습에 필요한 사용자의 노력 정도에 따른 특성

### 운용성(Operability)

소프트웨어의 운용과 운용 통제에 필요한 사용자의 노력 정도에 따른 특성

## 효율성(Efficiency)

시스템이 일정한 시간 또는 작동되는 시간 동안 의도하는 기능을 수행함을 보증하는 품질 기준

### 시간 효율성(Time Behaviour)

할당된 시간에 한정된 자원으로 얼마나 빨리 처리할 수 있는가에 대한 품질 기준

### 시간 효율성(Time Behaviour)

소프트웨어의 기능을 수행하는 데 있어서 반응 시간, 처리 시간 및  처리율에 따른 소프트웨어 특성

### 자원 효율성(Resource Behaviour)

소프트웨어의 기능을 수행하는 데 있어서 사용되는 자원의 양과 그 지속 시간에 따른 특성

## 유지보수성(Maintainability)(UI 품질 요구사항)

요구사항을 개선하고 확장하는 데 있어 얼마나 용이한가에 대한 품질 기준

### 분석성(Ananlyability)

소프트웨어 고장의 원인이나 결함 진단 또는 수정이 요구되는 부분의 확인에 필요한 노력 정도에 따른 소프트웨어 특성

### 변경성(Changeability)

결함 제거 또는 환경 변화에 따른 수정에 필요한 노력 정도에 따른 특성

### 안전성(Stability)

소프트웨어의 변경으로 발생하는 예상치 못한 영ㅎ양에 의한 위험 요소에 따른 특성

### 사회성(Testability)

소프트웨어가 변경되어 검증에 필요한 노력의 정도에 따른 특성

## 이식성(Portability)

다른 플랫폼 (운영체제)에서도 많은 추가 작업 없이 얼마나 쉽게 적용이 가능한가에 대한 품질 기준

### 적용성(Adaptability)

고려된 소프트웨어의 목적을 위해 제공된 수단이나 다른 조치 없이 특정 환경으로 전환되는 능력에 따른 소프트웨어 특성

### 설치성(Installability)

특정 환경에 소프트웨어를 설치하는 데 필요한 노력의 정도에 따른 특성

### 대체성(Resplaceability)

특정 운용 환경 하에서 동일한 목적 달성을 위해 다른 소프트웨어를 대신 사용할 수 있는 능력

## UI 지침

UI 표준에 따라 사용자 인터페이스 설계, 개발 시 지켜야 할 세부사항을 규정하는 가이드라인

## 3C 분석

고객(Customer), 자사(Competitor)를 비교하고 분석하여 자사를 어떻게 차별화해서 경쟁에서 이길 것인가를 분석하는 기법

## SWOT 분석

기업의 내부 환경과 외부 환경을 분석하여 Strength(강점), Weakness(약점), Opportunity(기회), Threat(위협) 요인을 규정하고 이를 토대로 경영 전략을 수립하는 방법

## 시나리오 플래닝(Scenario Planning)

불확실성이 높은 상황 변화를 사전에 예측하고 다양한 시나리오를 설계하는 방법

## 사용성 테스트(Usability Test)

사용자가 직접 제품을 사용하면서 미리 작성된 시나리오에 맞추어 과제를 수행한 후, 질문에 답하도록 하는 테스트

## 워크숍(Workshop)

소집단 정도의 인원으로 특정 문제나 과제에 대한 새로운 지식, 기술, 앙이디어, 방법들을 서로 교환하고 검토하는 연구회 및 세미나

## 페르소나 정의(UI 개발 시 사용자 요구사항 도출 1단계)

잠재적 사용자의 다양한 목적가 관찰된 행동 패턴을 응집시켜 놓은 가상의 사용자

## 콘셉트 모델 정의(UI 개발 시 사용자 요구사항 도출 2단계)

여러 가지 추상적인 콘셉트들 사이의 관계를 보여주는 다이어그램

## 사용자 요구사항 정의(UI 개발 시 사용자 요구사항 도출 3단계)

리서치 및 페르소나 결과물을 토대로 요구사항을 도출하고, 우선순위를 정함

## UI 컨셉션(UI 개발 시 사용자 요구사항 도출 4단계)

정리된 요구사항을 구체화하는 단계로 화면 디자인 단게 전에 대표 화면 설계를 진행하는 단계

## 와이어프레임(Wireframe)

이해관계자들과의 화면 구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업)

(ex. 파워포인트, 키노트, 스케치, 일러스트)

## 스토리보드(Storyboard)

서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물(ex. 파워포인트, 키노트, 스케치)

## 프로토타입(Prototype)

정적인 화면으로 설계된 와이어플레임 또는 스트리보드에 동적 효과를 적용하여 실제 구현된 것처럼 사물레이션할 수 잇는 모형(ex. HTML/CSS)

## UML(Unified Modeling Language)

객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 용어

## 가시화 언어(UML의 특징)

개념 모델 작성 시 오류가 적고 의사소통이 용이

## 구축 언어(UML의 특징)

다양한 프로그래밍 언어로 실행 시스템의 예측 가능

## 문서화 언어(UML의 특징)

시스템에 대한 평가 및 의사소통의 문서

## UML의 구성 요소

### 사물(Things)

추상적인 개념으로, 주제를 나타내는 요소

### 관계(Relationships)

사물의 의미를 확장하고 명확히 하는 요소

### 다이어그램(Diagrams)

사물과 관계를 모아 그림으로 표현한 형태

## 클래스 다이어그램(Class Diagram)

구조적 다이어그램 중 하나로, 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램

## 객체 다이어그램(Object Diagram)

구조적 다이어그램 중 하나로, 클래스에 속한 사물(객체)들, 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현한 다이어그램

## 컴포넌트 다이어그램(Component Diagram)

구조적 다이어그램 중 하나로, 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램

## 배치 다이어그램(Deployment Diagram)

구조적 다이어그램 중 하나로, 컴포넌트 사이의 중속성을 표현하고, 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현하는 다이어 그램

## 복합체 구조 다이어그램(Compositye Structure)

구조적 다이어그램 중 하나로, 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현하는 다이어그램

## 패키지 다이어그램(Package Diagram)

구조적 다이어그램 중 하나로, 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한 다이어그램

## 유스케이스 다이어그램(Usecase Diagram)

행위적 다이어그램 중 하나로, 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램

## 시퀀스 다이어그램(Sequence Diagram)

행위적 다이어그램 중 하나로, 객체 간 동적 상호작용을 시간적 개념을 중심으로 메시지 흐름으로 표현한 다이어그램

## 커뮤니케이션 다이어그램(Communication Diagram)

행위적 다이어그램 중 하나로, 동작에 참여하는 객체들이 주고 받는 메시지를 표현하고, 메시지뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램

## 상태 다이어그램(State Diagram)

행위적 다이어그램 중 하나로, 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용데 따라 상태가 어떻게 변화하는지 표현하는 다이어그램

## 활동 다이어그램(Activity Diagram)

행위적 다이어그램 중 하나로, 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램

## 타이밍 다이어그램(Timing Diagram)

행위적 다이어그램 중 하나로, 객체 상태 변화와 시간 제약을 명시적으로 표현하는 다이어그램

## <<include>>

UML 확장 모델의 스테레오 타입 중 하나로, 하나의 유스케이스가 어떤 시점에 반드시 다른 유스케이스를 실행하는 포함 관계

## <<extend>>

UML 확장 모델의 스테레오 타입 중 하나로, 하나의 유스케이스가 어떤 시점에 다른 유스케이스를 실행할 수 있고, 그렇지 않을 수도 잇는 확장 관계

## <<interface>>

UML 확장 모델의 스테레오 타입 중 하나로, 모든 메서드가 추상 메서드이며 바로 인스턴스를 만들 수 없는 클래스로 추상 메서드와 상수만으로 구성된 클래스

## <<entry>>

UML 확장 모델의 스테레오 타입 중 하나로, 유스케이스 처리 흐름이 수행되는 과정에서 기억 장치에 저장되어야 할 정보를 표현하는 클래스

## <<boundary>>

UML 확장 모델의 스테레오 타입 중 하나로, 시스템과 외부 엑터와의 상호작요을 담당하는 클래스

## <<control>>

UML 확장 모델의 스테레오 타입 중 하나로, 시스템이 제공하는 기능의 로직 및 제어를 담당하는 클래스

## 연관 관계

클래스가 서로 개념적으로 연결된 선

## 집합 관계

하나의 객체에 여러 개의 독립적인 객체들이 구성되는 관계(속이 빈 마름모)

## 복합 관계

영구적이고, 집합 관계보다 더 강한 관계로 구성 (속이 채워진 마름모)

## 일반화 관계

하나의 사물이 다른 사물에 비해 더 일반적인지 구체인지를 표현 (속이 빈 화살표)

## 의존 관계

하나의 클래스가 또 다른 클래스를 사용하는 관계 (점선 화살표)

## 시퀀스 다이어그램 구성요소

### 객체(Object)

객체는 위쪽에 표시되며 아래로 생명선을 가짐

### 생명선(Lifeline)

객체로부터 뻗어 나가는 점선

### 실행(Activation)

직사각형은 오퍼레이션(함수)이 실행되는 시간을 의미

### 메시지(Message)

객체 간의 상호작용은 메시지 교환으로 이루어짐

## 패키지 다이어그램 구성요소

### 패키지

요소들을 그룹으로 조직하기 위한 요소

### 외존관계

하나의 패키지가 다른 패키지를 사용하는 관계

## UI 시나리오 문서의 작성 요건

### 완전성(Complete)

UI 시나리오는 누락이 없어야 하고, 최대한 빠짐 없이 가능한 한 상세하게 기술

### 일관성(Consistent)

서비스에 대한 목표, 시스템 및 사용자의 요구사항이 일관성이 있어야 하고, 모든 문서의 UI 스타일을 일관적으로 구성

### 이해성(Understandance)

처음 접하는 사람도 이해하기 쉽도록 구성하여 설명해야 하고, 이해하지 못하는 사람은 추상적인 표현이나 이해하기 어려운 용어는 사용하지 않아야 함

### 가독성(Readable)

문서를 쉽게 읽을 수 있어야 하고, 표준화된 탬플릿을 작성하여 사용

### 추적 용이성(Traceable)

쉽게 추적이 가능해야 하고, 변경 사항들이 언제, 어디서, 어떤 부분들이, 왜 발생하였는지 추적이 쉬워야 함

### 수정 용이성(Modifiable)

쉽게 변경이 가능해야 하고, 수정 또는 개선 사항을 시나리오에 반영하는 데 있어 쉽게 적용할 수 있어야 함

## 파워 목업
